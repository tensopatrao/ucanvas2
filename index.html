<html>
	<head>
		<title>uCanvas.io</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}
			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}
			#instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;
				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;
				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;
				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;
				color: #ffffff;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		

		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>

		<script src="app/js/three.js"></script>
		<script src="app/js/libs/inflate.min.js"></script>
		<script src="app/js/loaders/FBXLoader.js"></script>
		<script src="app/js/loaders/GLTFLoader.js"></script>
		<script src="app/js/utils/SceneUtils.js"></script>
		<script src="app/js/WebGL.js"></script>
		<script src="app/js/socketio.js"></script>
		<script src='app/js/threex.keyboardstate.js'></script>
		<script src="app/js/controls/PointerLockControls.js"></script>
		
		<script>
			THREE.ShaderLib[ 'lambert' ].fragmentShader = THREE.ShaderLib[ 'lambert' ].fragmentShader.replace(

			`vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;`,

			`#ifndef CUSTOM
				vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
			#else
				vec3 outgoingLight = diffuseColor.rgb * ( 1.0 - 0.5 * ( 1.0 - getShadowMask() ) ); // shadow intensity hardwired to 0.5 here
			#endif`

			);
		</script>
		<script>
			
			var FPS=true;
			
			
			var scene2 = new THREE.Scene();
			var camera2 = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.01, 10000 );
			camera2.name="Camera2";
			scene2.add(camera2);
			
			var scene = new THREE.Scene();
			var camera=null;
			var renderer = new THREE.WebGLRenderer();
			
			//Connect to Server 

			var uc = this;
			
			var keyboard= new THREEx.KeyboardState();
			
			var controls;
			
			var canMove;
			canMove=false;
			
			//document.addEventListener('mousemove', onMouseMove, false);
			
			uc.finishedLoading=false;
			uc.loading=0;
			
			uc.wait4server=true;
			uc.connected=false;
			
			uc.IDs=[];
			uc.objNames=[];
			uc.parentNames=[];
			uc.values=[];
			uc.unique=[];
			
			uc.entities=[];
			
			uc.Pos=[];
			uc.Scl=[];
			uc.Rot=[];
			uc.Extra=[];
			
			uc.myCam;
			uc.myCamTarget;
			uc.myCamTargetName;
			
			var playerNumber=0;
			var configured=false;

				
			//var geometry = new THREE.BoxGeometry( 100, 100, 100 );
			//var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			
			//FPS SPECIFIC CODE
			var thisEntity = new THREE.Object3D();
			var sight ;
			var pitchObject = new THREE.Object3D();
			var yawObject = new THREE.Object3D();
			yawObject.add( pitchObject );
			scene.add( yawObject );
			
			var FPScam;

			var PI_2 = Math.PI / 2;
			
			controls = new THREE.PointerLockControls( thisEntity );
				
				instructions.addEventListener( 'click', function () {
					controls.lock(); canMove=true;
				}, false );
				controls.addEventListener( 'lock', function () {
					instructions.style.display = 'none';
					blocker.style.display = 'none';
				} );
				controls.addEventListener( 'unlock', function () {
						canMove=false;
					blocker.style.display = 'block';
					instructions.style.display = '';
				} );
				
			var mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };
			
			document.addEventListener( 'mousedown', onMouseDown, false );
			document.addEventListener( 'mouseup', onMouseUp, false );
			
			var socket = io.connect('wss://www.ucanvas.io:443');
			socket.emit ('userInit', 'uCanvasClient');
			
			socket.on ('welcome', function (data, data2) { //Connection Established, configure uCanvas accordingly
				uc.objNames=data;
				uc.parentNames=data2;
				
				//console.log(data);
				
				uc.Pos.push(new THREE.Vector3( 1, 1, 1 ));
				uc.Scl.push(new THREE.Vector3( 1, 1, 1 ));
				uc.Rot.push(new THREE.Quaternion());
				uc.Extra.push(0);
				uCanvasScenePreLoad();
			});
    
			socket.on ('ucUpdate', function (data,data2) { //Server Update
				var bufView = new Uint16Array(data);
				var bufView2 = new Float32Array(data2);
				
				
				
				uc.IDs=bufView;
				//console.log(uc.IDs);
				uc.values=bufView2;
				//console.log(uc.values);
				uc.wait4server=false;
				uc.connected=true;
			});
			
			socket.on ('playerJoined', function (data,data2) { //Server Update
				uc.myCamTargetName=""+data2;
				playerNumber=data;
				console.log("PLAYER JOINED: " + data);
			});
			
			
			
			
			
			
			
			//Start Three.js and create Scene
			
			
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;; 
			renderer.autoClear = false;
			var light = new THREE.AmbientLight(0xffffff,0.8 ); // soft white light
			light.castShadow=false;
			scene.add( light );
			
			window.addEventListener( 'resize', onWindowResize, false );
			
			dirLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				dirLight.position.set( 0, 1, 0 );
				dirLight.position.multiplyScalar( 30 );
				dirLight.castShadow=true;
				scene.add( dirLight );
								dirLight.castShadow = true;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				var d = 20;
				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;
				dirLight.shadow.camera.far = 1000;
				dirLight.shadow.bias = - 0.00001;
				//dirLight.shadow.camera.position.set(dirLight.shadow.camera.position.x,dirLight.shadow.camera.position.y-20,dirLight.shadow.camera.position.z);
			
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			
			
			
			//Update Loop

			var animate = function () {
				requestAnimationFrame( animate );
				
				uc.myCam=scene.getObjectByName(uc.myCamTargetName); //MELHORAR, ISTO EH HORRIVEL
				if(uc.myCam!=null){uc.myCamTarget=uc.myCam;}
				
				if(uc.connected && uc.loading==0){
					
					if(!uc.finishedLoading){ uCanvasSceneLoad(); } //ISTO NAO EH CHAMADO MAIS KE UMA VEZ?
					
					if(!uc.wait4server){
						readPackage();
						uc.wait4server=true;
					}
				
					
					//cube.position.x += 0.01;
					//cube.rotation.y += 0.01;
					var e=0;
					var myparent=uc.entities[0];
					
					
					while(e<uc.entities.length){
						uc.entities[e].visible=false;
						e++;
					}
					e=0;
					while(e<uc.IDs.length){
							uc.entities[uc.IDs[e]].visible=true;
							var lerpValue=0.3;
							
							var vec=new THREE.Vector3( uc.Pos[uc.IDs[e]].x-uc.entities[uc.IDs[e]].position.x, uc.Pos[uc.IDs[e]].y-uc.entities[uc.IDs[e]].position.y, uc.Pos[uc.IDs[e]].z-uc.entities[uc.IDs[e]].position.z );
							if(vec.lengthSq()>5.5){
								lerpValue=1;
							}
							var thisScl=uc.entities[uc.IDs[e]].scale.lerp( new THREE.Vector3(-0.01*uc.Scl[uc.IDs[e]].x, 0.01*uc.Scl[uc.IDs[e]].y, 0.01*uc.Scl[uc.IDs[e]].z),0.7 );
							uc.entities[uc.IDs[e]].scale.set(thisScl.x, thisScl.y, thisScl.z);
							thisPos=uc.entities[uc.IDs[e]].position.lerp( new THREE.Vector3(uc.Pos[uc.IDs[e]].x, uc.Pos[uc.IDs[e]].y, uc.Pos[uc.IDs[e]].z),lerpValue );
							uc.entities[uc.IDs[e]].position.set(thisPos.x, thisPos.y, thisPos.z);
							thisRot=uc.entities[uc.IDs[e]].quaternion.slerp( new THREE.Quaternion(uc.Rot[uc.IDs[e]].x,uc.Rot[uc.IDs[e]].y,uc.Rot[uc.IDs[e]].z,uc.Rot[uc.IDs[e]].w),lerpValue );
							if(!configured){
								
								if(playerNumber==uc.Extra[uc.IDs[e]]){ 
									console.log(uc.entities[uc.IDs[e]].name.substring(5,uc.entities[uc.IDs[e]].name.length));
									scene2.add(uc.entities[uc.IDs[e]]);
									var thisName=uc.entities[uc.IDs[e]].name.substring(5,uc.entities[uc.IDs[e]].name.length);
									if(thisName=="HEAD"){
										scene2.remove(uc.entities[uc.IDs[e]]);
										scene.remove(uc.entities[uc.IDs[e]]);
									}
									else if(thisName=="TORSO"){
										scene2.remove(uc.entities[uc.IDs[e]]);
										scene.remove(uc.entities[uc.IDs[e]]);
									}
									else if(thisName=="CameraFPS"){
										FPScam=uc.entities[uc.IDs[e]];
										var geometry = new THREE.BoxGeometry( 0.005, 0.005, 0.005 );
										var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
										sight = new THREE.Mesh(geometry,material);
										pitchObject.add(sight);
										sight.position.set(0,-0.05,0);
										sight.position.z+=-1;
									}
									else if(thisName=="Muzzle3d3"){
										var object=uc.entities[uc.IDs[e]];
										object.mixer = new THREE.AnimationMixer( object );
										mixers.push( object.mixer );
										var action = object.mixer.clipAction( object.animations[ 0 ] );
										action.setLoop( THREE.Loop )
										action.play();
									}
									
								}
							}
						
						//if(uc.parentNames[e]!="none"){ 
							//THREE.SceneUtils.attach(uc.entities[e],scene,myparent);
						//}
						
						//uc.entities[e].position.set(uc.Pos[e].x, uc.Pos[e].y, uc.Pos[e].z);
						//uc.entities[e].scale.set(0.01, 0.01, 0.01);
						
						e++;
					}
					//camera.scale.set(1,1,1);
					configured=true;
					if(camera!=null){
						if(FPScam!=null){yawObject.position.set(FPScam.position.x,FPScam.position.y,FPScam.position.z);}
						//yawObject.position.set(uc.myCamTarget.position.x,uc.myCamTarget.position.y,uc.myCamTarget.position.z+404);
						camera2.position.set(uc.myCamTarget.position.x,uc.myCamTarget.position.y,uc.myCamTarget.position.z);
						camera2.rotation.set(uc.myCamTarget.rotation.x,uc.myCamTarget.rotation.y,uc.myCamTarget.rotation.z,uc.myCamTarget.rotation.w);
						dirLight.position.set(camera.position.x,1000,camera.position.z);
						dirLight.target=camera;
						
						//renderer.render( scene, camera ); 

						renderer.clear();
						renderer.render( scene, camera );
						renderer.clearDepth();
						renderer.render( scene2, camera2 );
						
					}
					
					
				}
				
			};
			
			animate();
			
			
			//CONTROLS
			
			keyboard.domElement.addEventListener('keydown', function(event){
				if( keyboard.eventMatches(event, 'W') )	socket.emit('keydown', 1);
				if( keyboard.eventMatches(event, 'S') )	socket.emit('keydown', 2);
				if( keyboard.eventMatches(event, 'D') )	socket.emit('keydown', 3);
				if( keyboard.eventMatches(event, 'A') )	socket.emit('keydown', 4);
				if( keyboard.eventMatches(event, 'space') )	socket.emit('keydown', 5);
				if( keyboard.eventMatches(event, 'shift') )	 socket.emit('keydown', 6);
				if( keyboard.eventMatches(event, 'R') )	socket.emit('keydown', 7);
			})

			keyboard.domElement.addEventListener('keyup', function(event){
				if( keyboard.eventMatches(event, 'W') )	socket.emit('keyup', 1);
				if( keyboard.eventMatches(event, 'S') )	socket.emit('keyup', 2);
				if( keyboard.eventMatches(event, 'D') )	socket.emit('keyup', 3);
				if( keyboard.eventMatches(event, 'A') )	socket.emit('keyup', 4); 
				if( keyboard.eventMatches(event, 'space') )	socket.emit('keyup', 5);
				if( keyboard.eventMatches(event, 'lshift') ) console.log("deu");	socket.emit('keyup', 6);
				if( keyboard.eventMatches(event, 'R') )	socket.emit('keyup', 7);
			})
			
			
			function onMouseMove( event ) {
			if(canMove){
				
				var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
				var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
				yawObject.rotation.y -= movementX * 0.001;
				pitchObject.rotation.x -= movementY * 0.001;
				while(yawObject.rotation.y>PI_2*2){
					yawObject.rotation.y-=PI_2*4;
				}
				while(yawObject.rotation.y<-PI_2*2){
					yawObject.rotation.y+=PI_2*4;
				}
				while(pitchObject.rotation.x>PI_2*2){
					pitchObject.rotation.x-=PI_2*4;
				}
				while(pitchObject.rotation.x<-PI_2*2){
					pitchObject.rotation.x+=PI_2*4;
				}
				pitchObject.rotation.x = Math.max( - PI_2*0.85, Math.min( PI_2*0.85, pitchObject.rotation.x ) );
				//socket.emit('mouse', -movementX , movementY);
				socket.emit('mouse', 5+yawObject.rotation.y  , 5+pitchObject.rotation.x);
			}
				
			};
			
			function onMouseDown( event ) {


				event.preventDefault();

				switch ( event.button ) {

					case mouseButtons.LEFT:
						if(FPS){socket.emit('mouse', 5+yawObject.rotation.y  , 5+pitchObject.rotation.x);}
						socket.emit('keydown', 8);

					break;

					case mouseButtons.MIDDLE:

				

					break;

					case mouseButtons.RIGHT:
				
						socket.emit('keydown', 9);

					break;

				}


			}	
			
			function onMouseUp( event ) {


				event.preventDefault();

				switch ( event.button ) {

					case mouseButtons.LEFT:

						socket.emit('keyup', 8);

					break;

					case mouseButtons.MIDDLE:

						

					break;

					case mouseButtons.RIGHT:
				
						socket.emit('keyup', 9);

					break;

				}


			}	
			
			
			//FUNCTIONS
			
			var readPackage = function () {
				var i=0;
				
				while(i<uc.IDs.length){
					uc.Scl[uc.IDs[i]]=new THREE.Vector3(uc.values[i*11+7], uc.values[i*11+8], uc.values[i*11+9]); //SCALE VEC3 + SERVER TIME FLOAT
					uc.Pos[uc.IDs[i]]=new THREE.Vector3(uc.values[i*11], uc.values[i*11+1], uc.values[i*11+2]); //POSITION VEC3
					uc.Rot[uc.IDs[i]]=new THREE.Quaternion(uc.values[i*11+3], uc.values[i*11+4], uc.values[i*11+5], uc.values[i*11+6]); //ROTATION QUAT   
					uc.Extra[uc.IDs[i]]=uc.values[i*11+10];
					i++;
				}
								
			};
			
			function uCanvasScenePreLoad(){
				var i = 0; 
    
                
				var myEntity;
				var myComparision;
				
				var e=0;
				
				var wasLoaded=false;
								
				//PRELOADER #################################################################################################################
						while(i<uc.objNames.length){
							
							//console.log(unique);
							
							wasLoaded=false;
							
							var assetName=uc.objNames[i].substring(5,uc.objNames[i].length);
							
							e=0;
							while(e<uc.unique.length){
								if(uc.unique[e]==assetName){ wasLoaded=true; }
								e++;
							}
							
							if(!wasLoaded){
							
								uc.unique.push(assetName);
							
								myEntity = null;
								myEntity = scene.getObjectByName(assetName + ".fbx" )
								if(myEntity==null){
                    
        
									if(!fileExists("app/models/" + assetName + ".fbx")){ 
										console.log("Asset '"+assetName+".fbx' not found. Using cube instead of Mesh."); 
									}
									else{
										console.log("Asset '"+assetName+".fbx' Loaded."); 
										uc.loading+=1;
										//LoadGLTF(assetName);
										LoadFBX(assetName);
									}
							}
                        
							}
						i++;
						}
				//###################################################################################################################################
        
			
		}

		function uCanvasSceneLoad(){
				var i = 0; 
    
                
				var myEntity;
				var myComparision;
								
        
			while(i<uc.objNames.length){
            
				//OBJECT LOADER #################################################################################################################
                var assetName=uc.objNames[i].substring(5,uc.objNames[i].length);
            
                    var myComparision = null;
                    myComparision = scene.getObjectByName(assetName+".fbx");
                        
                        if(myComparision==null){
								
                                //var geometry = new THREE.BoxGeometry( 100, 100, 100 );
								//var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
								myEntity = new THREE.Object3D();
								myEntity.visible=false;
								
								
                        }
                        else{
						//console.log("FOUND!!!");
                            myEntity=myComparision.clone(); //Clone preloaded object     
                        }
						
                        myEntity.name=uc.objNames[i];
                        
                        
                        //myThis.caralho.push(myEntity.script.uCanvasEntity);
                        
						//if(ucParentNames[i]!="none"){ myEntity.script.uCanvasEntity.parentName=ucParentNames[i]; }
                        //else{myEntity.script.uCanvasEntity.parentName="none";}
                
                switch (assetName){
                    case "Camera":
						
						camera = new THREE.PerspectiveCamera( 64, window.innerWidth/window.innerHeight, 0.01, 10000 );
						camera.name="Camera";
						scene.add(camera);
						myEntity = new THREE.Object3D();
						myEntity.name=uc.objNames[i];
						if(uc.myCamTarget==null){uc.myCamTarget=myEntity;}
						yawObject.position.set(camera.position.x,camera.position.x,camera.position.z);
						pitchObject.add(camera);
						
				
						
						
						
                        console.log("Camera created!");
                    break;
					
					 case "Cube":
						
						var geometry2 = new THREE.BoxGeometry( 100, 100, 100 );
						var material2 = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
						myEntity= new THREE.Mesh( geometry2, material2);
						
                    break;
                    default:
                    break;
                }
				uc.entities.push(myEntity);
				scene.add(myEntity);
            //###################################################################################################################################
            i++;
		}
		
		e=0;
		while(e<uc.unique.length){
			scene.remove(scene.getObjectByName(uc.unique[e]+".fbx"));
			e++;
		}
		
		e=0;
		while(e<uc.entities.length){
			if(uc.parentNames[e]!="none"){
				THREE.SceneUtils.attach(uc.entities[e],scene,scene.getObjectByName(uc.parentNames[e]));
			}
			e++;
		}
		
				
		uc.finishedLoading=true;
		//
		}
			
			function lerp (start, end, amt){
				return (1-amt)*start+amt*end
			}
			
			function fileExists(url)
{
				var http = new XMLHttpRequest();
				http.open('HEAD', url, false);
				http.send();
				return http.status!=404;
			}
			
			
			function LoadFBX(assetName){
					var thisObj=assetName;
					var loader = new THREE.FBXLoader();
					var texture = new THREE.TextureLoader().load( "app/models/palette.jpg" );
					//var thismaterial = new THREE.MeshLambertMaterial();
					//thismaterial.defines = thismaterial.defines || {};
					//thismaterial.defines.CUSTOM = "";
					
					loader.load( "app/models/" + assetName + ".fbx", function ( object ) {
						var xupa=new THREE.MeshBasicMaterial();
						xupa.map=texture;
						object.traverse( function ( child ) {
							if ( child.isMesh ) {
								child.castShadow = true;
								//child.receiveShadow = true;
								
								//xupa.color=child.material.color;
								//xupa.map=child.material.map;
								child.material=xupa;
								//xupa.copy(child.material);
								//child.material=xupa;
								//child.material.lights=false;
								//child.material.flatShading=true;
								//console.log(child.material.length);
								
							}
						} );
					object.name=thisObj + ".fbx";
					
					/*var thismaterial = new THREE.MeshLambertMaterial( { map: texture } );
					thismaterial.defines = thismaterial.defines || {};
					thismaterial.defines.CUSTOM = "";
					thismaterial.vertexColors=THREE.FaceColors;*/
					
					scene.add( object );
					console.log(object.name);
					//object.position.set(0, 1000000, 0);
					uc.loading-=1;

					} );
			}
			

			
		</script>
	</body>
</html>