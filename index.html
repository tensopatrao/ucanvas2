<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="app/js/three.js"></script>
		<script src="app/js/libs/inflate.min.js"></script>
		<script src="app/js/loaders/FBXLoader.js"></script>
		<script src="app/js/loaders/GLTFLoader.js"></script>
		<script src="app/js/utils/SceneUtils.js"></script>
		<script src="app/js/WebGL.js"></script>
		<script src="app/js/socketio.js"></script>
		<script>
			THREE.ShaderLib[ 'lambert' ].fragmentShader = THREE.ShaderLib[ 'lambert' ].fragmentShader.replace(

			`vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;`,

			`#ifndef CUSTOM
				vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
			#else
				vec3 outgoingLight = diffuseColor.rgb * ( 1.0 - 0.5 * ( 1.0 - getShadowMask() ) ); // shadow intensity hardwired to 0.5 here
			#endif`

			);
		</script>
		<script>
			
			//Connect to Server 

			var uc = this;
			
			uc.finishedLoading=false;
			uc.loading=0;
			
			uc.wait4server=true;
			uc.connected=false;
			
			uc.IDs=[];
			uc.objNames=[];
			uc.parentNames=[];
			uc.values=[];
			uc.unique=[];
			
			uc.entities=[];
			
			uc.Pos=[];
			uc.Scl=[];
			uc.Rot=[];
			
			var socket = io.connect('wss://www.ucanvas.io:443');
			socket.emit ('userInit', 'uCanvasClient');
			
			socket.on ('welcome', function (data, data2) { //Connection Established, configure uCanvas accordingly
				uc.objNames=data;
				uc.parentNames=data2;
				
				console.log(data);
				
				uc.Pos.push(new THREE.Vector3( 0, 0, 0 ));
				uc.Scl.push(new THREE.Vector3( 0, 0, 0 ));
				uc.Rot.push(new THREE.Quaternion());
				uCanvasScenePreLoad();
			});
    
			socket.on ('ucUpdate', function (data,data2) { //Server Update
				var bufView = new Uint16Array(data);
				var bufView2 = new Float32Array(data2);
        
				uc.IDs=bufView;
				uc.values=bufView2;
				uc.wait4server=false;
				uc.connected=true;
			});
			
			
			
			
			
			
			
			//Start Three.js and create Scene
			
			var scene = new THREE.Scene();
			var camera=null;
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;; 
			var light = new THREE.AmbientLight(0xffffff,0.8 ); // soft white light
			light.castShadow=false;
			scene.add( light );
			
			dirLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
				dirLight.position.set( 0, 1, 0 );
				dirLight.position.multiplyScalar( 30 );
				dirLight.castShadow=true;
				scene.add( dirLight );
								dirLight.castShadow = true;
				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;
				var d = 20;
				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;
				dirLight.shadow.camera.far = 1000;
				dirLight.shadow.bias = - 0.00001;
				//dirLight.shadow.camera.position.set(dirLight.shadow.camera.position.x,dirLight.shadow.camera.position.y-20,dirLight.shadow.camera.position.z);

			
			
			
			
			
			//Update Loop

			var animate = function () {
				requestAnimationFrame( animate );
				
				if(uc.connected && uc.loading==0){
					
					if(!uc.finishedLoading){ uCanvasSceneLoad(); }
					
					if(!uc.wait4server){
						readPackage();
						uc.wait4server=true;
					}
				
					
					//cube.position.x += 0.01;
					//cube.rotation.y += 0.01;
					var e=0;
					var myparent=uc.entities[0];
					while(e<uc.entities.length){
						
						
						
						if(uc.parentNames[e]=="none"){ 
							
							uc.entities[e].scale.set(-0.01*uc.Scl[e].x, 0.01*uc.Scl[e].y, 0.01*uc.Scl[e].z);
							thisPos=uc.entities[e].position.lerp( new THREE.Vector3(uc.Pos[e].x, uc.Pos[e].y, uc.Pos[e].z),0.3 );
						uc.entities[e].position.set(thisPos.x, thisPos.y, thisPos.z);
						thisRot=uc.entities[e].quaternion.slerp( new THREE.Quaternion(uc.Rot[e].x,uc.Rot[e].y,uc.Rot[e].z,uc.Rot[e].w),0.3 );
						uc.entities[e].quaternion.set(thisRot.x,thisRot.y,thisRot.z,thisRot.w);
						}
						else{
							myparent=uc.entities[e].parent; 
							uc.entities[e].scale.set(1*uc.Scl[e].x, 1*uc.Scl[e].y, 1*uc.Scl[e].z);
							thisPos=uc.entities[e].position.lerp( new THREE.Vector3(-uc.Pos[e].x*100, uc.Pos[e].y*100, uc.Pos[e].z*100),0.3 );
							uc.entities[e].position.set(thisPos.x, thisPos.y, thisPos.z);
							thisRot=uc.entities[e].quaternion.slerp( new THREE.Quaternion(uc.Rot[e].x,-uc.Rot[e].y,uc.Rot[e].z,uc.Rot[e].w),0.3 );
							uc.entities[e].quaternion.set(thisRot.x,thisRot.y,thisRot.z,thisRot.w);
							//myparent=uc.entities[e].parent; 
							//THREE.SceneUtils.detach(uc.entities[e],myparent,scene);
						}
						
						
						
						if(uc.parentNames[e]!="none"){ 
							//THREE.SceneUtils.attach(uc.entities[e],scene,myparent);
						}
						
						
						//uc.entities[e].position.set(uc.Pos[e].x, uc.Pos[e].y, uc.Pos[e].z);
						//uc.entities[e].scale.set(0.01, 0.01, 0.01);
						
						e++;
					}
					camera.scale.set(1,1,1);
					
					if(camera!=null){
						//dirLight.position.copy( camera.position );
						//dirLight.target=camera;
						//dirLight.position.y += 20;
						//dirLight.position.z += 20;
						dirLight.position.set(camera.position.x,1000,camera.position.z);
						dirLight.target=camera;
						
						renderer.render( scene, camera ); 
					}
				}
				
			};
			
			animate();
			
			
			
			
			
			
			
			
			//FUNCTIONS
			
			var readPackage = function () {
				var i=0;
				
				while(i<uc.entities.length){
					uc.Scl[uc.IDs[i]]=new THREE.Vector3(uc.values[uc.IDs[i]*11+7], uc.values[uc.IDs[i]*11+8], uc.values[uc.IDs[i]*11+9]); //SCALE VEC3 + SERVER TIME FLOAT
					uc.Pos[uc.IDs[i]]=new THREE.Vector3(uc.values[uc.IDs[i]*11], uc.values[uc.IDs[i]*11+1], uc.values[uc.IDs[i]*11+2]); //POSITION VEC3
					uc.Rot[uc.IDs[i]]=new THREE.Quaternion(uc.values[uc.IDs[i]*11+3], uc.values[uc.IDs[i]*11+4], uc.values[uc.IDs[i]*11+5], uc.values[uc.IDs[i]*11+6]); //ROTATION QUAT   
                
					i++;
				}
								
			};
			
			function uCanvasScenePreLoad(){
				var i = 0; 
    
                
				var myEntity;
				var myComparision;
				
				var e=0;
				
				var wasLoaded=false;
								
				//PRELOADER #################################################################################################################
						while(i<uc.objNames.length){
							
							console.log(unique);
							
							wasLoaded=false;
							
							var assetName=uc.objNames[i].substring(5,uc.objNames[i].length);
							
							e=0;
							while(e<uc.unique.length){
								if(uc.unique[e]==assetName){ wasLoaded=true; }
								e++;
							}
							
							if(!wasLoaded){
							
								uc.unique.push(assetName);
							
								myEntity = null;
								myEntity = scene.getObjectByName(assetName + ".fbx" )
								if(myEntity==null){
                    
        
									if(!fileExists("app/models/" + assetName + ".fbx")){ 
										console.log("Asset '"+assetName+".fbx' not found. Using cube instead of Mesh."); 
									}
									else{
										console.log("Asset '"+assetName+".fbx' Loaded."); 
										uc.loading+=1;
										//LoadGLTF(assetName);
										LoadFBX(assetName);
									}
							}
                        
							}
						i++;
						}
				//###################################################################################################################################
        
			
		}
		
		function uCanvasSceneLoad(){
				var i = 0; 
    
                
				var myEntity;
				var myComparision;
								
        
			while(i<uc.objNames.length){
            
				//OBJECT LOADER #################################################################################################################
                var assetName=uc.objNames[i].substring(5,uc.objNames[i].length);
            
                    var myComparision = null;
                    myComparision = scene.getObjectByName(assetName+".fbx");
                        
                        if(myComparision==null){
								
                                var geometry = new THREE.BoxGeometry( 100, 100, 100 );
								var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
								myEntity = new THREE.Mesh( geometry, material );
								
								
                        }
                        else{
						console.log("FOUND!!!");
                            myEntity=myComparision.clone(); //Clone preloaded object     
                        }
						
                        myEntity.name=uc.objNames[i];
                        
                        
                        //myThis.caralho.push(myEntity.script.uCanvasEntity);
                        
						//if(ucParentNames[i]!="none"){ myEntity.script.uCanvasEntity.parentName=ucParentNames[i]; }
                        //else{myEntity.script.uCanvasEntity.parentName="none";}
                
                switch (assetName){
                    case "Camera":
					
						camera = new THREE.PerspectiveCamera( 64, window.innerWidth/window.innerHeight, 0.01, 10000 );
						myEntity=camera;
                        console.log("Camera created!");
                    break;
                    default:
                    break;
                }
				uc.entities.push(myEntity);
				scene.add(myEntity);
            //###################################################################################################################################
            i++;
		}
		
		e=0;
		while(e<uc.unique.length){
			scene.remove(scene.getObjectByName(uc.unique[e]+".fbx"));
			e++;
		}
		
		e=0;
		while(e<uc.entities.length){
			if(uc.parentNames[e]!="none"){
				THREE.SceneUtils.attach(uc.entities[e],scene,scene.getObjectByName(uc.parentNames[e]));
			}
			e++;
		}
				
		uc.finishedLoading=true;
		//
		}
			
			function lerp (start, end, amt){
				return (1-amt)*start+amt*end
			}
			
			function fileExists(url)
{
				var http = new XMLHttpRequest();
				http.open('HEAD', url, false);
				http.send();
				return http.status!=404;
			}
			
			function LoadGLTF(assetName){
				// Instantiate a loader
				var loader = new THREE.GLTFLoader();

				// Optional: Provide a DRACOLoader instance to decode compressed mesh data
				//THREE.DRACOLoader.setDecoderPath( '/examples/js/libs/draco' );
				//loader.setDRACOLoader( new THREE.DRACOLoader() );

				// Load a glTF resource
				loader.load('models/' + assetName + '.glb',function ( gltf ) {

					scene.add( gltf.scene );

					//gltf.animations; // Array<THREE.AnimationClip>
					//gltf.scene; // THREE.Scene
					//gltf.scenes; // Array<THREE.Scene>
					//gltf.cameras; // Array<THREE.Camera>
					//gltf.asset; // Object

				},
				// called while loading is progressing
				function ( xhr ) {

					console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

				},
				// called when loading has errors
				function ( error ) {

					console.log( 'An error happened' );

					});
			}
			
			function LoadFBX(assetName){
					var thisObj=assetName;
					var loader = new THREE.FBXLoader();
					var texture = new THREE.TextureLoader().load( "app/models/palette.jpg" );
					//var thismaterial = new THREE.MeshLambertMaterial();
					//thismaterial.defines = thismaterial.defines || {};
					//thismaterial.defines.CUSTOM = "";
					
					loader.load( "app/models/" + assetName + ".fbx", function ( object ) {
						/*object.mixer = new THREE.AnimationMixer( object );
						mixers.push( object.mixer );
						var action = object.mixer.clipAction( object.animations[ 0 ] );
						action.play();*/
						var xupa=new THREE.MeshBasicMaterial();
						xupa.map=texture;
						object.traverse( function ( child ) {
							if ( child.isMesh ) {
								child.castShadow = true;
								//child.receiveShadow = true;
								
								//xupa.color=child.material.color;
								//xupa.map=child.material.map;
								child.material=xupa;
								//xupa.copy(child.material);
								//child.material=xupa;
								//child.material.lights=false;
								//child.material.flatShading=true;
								//console.log(child.material.length);
								
							}
						} );
					object.name=thisObj + ".fbx";
					
					/*var thismaterial = new THREE.MeshLambertMaterial( { map: texture } );
					thismaterial.defines = thismaterial.defines || {};
					thismaterial.defines.CUSTOM = "";
					thismaterial.vertexColors=THREE.FaceColors;*/
					
					scene.add( object );
					console.log(object.name);
					//object.position.set(0, 1000000, 0);
					uc.loading-=1;

					} );
			}
			

			
		</script>
	</body>
</html>